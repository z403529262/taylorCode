package test.taylor.com.taylorcode.kotlin.coroutine.mvi

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.bilibili.studio.search.base.SearchEffect
import com.bilibili.studio.search.base.SearchIntent
import com.bilibili.studio.search.base.SearchViewState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import test.taylor.com.taylorcode.BuildConfig
import test.taylor.com.taylorcode.kotlin.coroutine.mvvm.*
import test.taylor.com.taylorcode.retrofit.News
import test.taylor.com.taylorcode.retrofit.NewsFlowWrapper
import javax.net.ssl.SSLHandshakeException

class NewsViewModel(private val newsRepo: NewsRepo) : ViewModel() {

    private val TAG = "NewsViewModel"
    private val _feedsIntent = MutableSharedFlow<FeedsIntent>()

    private val eventChannel = Channel<FeedsEvent>()
    val eventFlow = eventChannel.receiveAsFlow()

//    val newsState =
//        _feedsIntent
//            .toNewsStateFlow()
//            .flowOn(Dispatchers.IO)
//            .shareIn(viewModelScope, SharingStarted.Eagerly)

    val _userInfoStateFlow = MutableStateFlow(UserInfoModel(loading = true))
    val userInfoStateFlow: StateFlow<UserInfoModel> = _userInfoStateFlow

    val newState2 :Flow<NewsState> =
        _feedsIntent
            .onEach { Log.v(TAG, "showNews() feedsIntent intent=$it") }
            .toPartialChangeFlow()
            .log("1")
            .sendEvent()
            .log("2")
            .runningFold(NewsState.initial) { oldState, partialChange -> partialChange.reduce(oldState) }
            .onEach { Log.v(TAG, "showNews() onEach() newState=$it") }
            .flowOn(Dispatchers.IO)
            .log("3")
            .stateIn(viewModelScope, SharingStarted.Eagerly, NewsState.initial)

    private fun <T> Flow<T>.log(state:String="0"): Flow<T> = onEach {
//        if (BuildConfig.DEBUG)
            when (it) {
                is SearchIntent -> Log.v(TAG, "log$state $it")
                is SearchEffect<*> -> Log.d(TAG, "log$state $it")
                is SearchViewState -> Log.e(TAG, "log$state $it")
                else -> Log.e(TAG, "log$state $it")
            }
    }

    fun send(intent: FeedsIntent) {
        viewModelScope.launch { _feedsIntent.emit(intent) }
    }

    /**
     * case: use StateFlow like LiveData
     */
//    fun fetchUserInfo() {
//        viewModelScope.launch {
//            delay(2000)
//            val userInfo = userInfoStateFlow.value.copy(userName = "taylor", loading = false)
//            _userInfoStateFlow.emit(userInfo)
//        }
//    }

    /**
     * case: process flow generated by repo, and convert repo data to ui model
     */
//    val userInfoSharedFlow =
//        flowOf(newsRepo.localUserInfoFlow, newsRepo.remoteUserInfoFlow)
//            .flattenMerge()
//            .map { UserInfoModel(userName = it.name, loading = false) }
//            .onStart { emit(UserInfoModel(userName = "", loading = true)) }
//            .shareIn(viewModelScope, SharingStarted.WhileSubscribed())

//    val newsFlow =
//        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow("1", "8"))
//            .flattenMerge()
//            .transformWhile {
//                emit(it.news)
//                !it.abort
//            }
//            .map { NewsState(it, false, isLoadingMore = false, errorMessage = "") }
//            .flowOn(Dispatchers.IO) // case: change the upstream thread
//            .onStart { emit(NewsState(emptyList(), true, false, "")) }
//            .catch {
//                if (it is SSLHandshakeException)
//                    emit(
//                        NewsState(
//                            emptyList(),
//                            false,
//                            isLoadingMore = false,
//                            errorMessage = "network error,show old news"
//                        )
//                    )
//            }
//            .shareIn(viewModelScope, SharingStarted.Lazily)

    /**
     * case: multiple flow in serial
     */
//    val newsSerialFlow =
//        flowOf(newsRepo.localNewsOneShotFlow, newsRepo.remoteNewsFlow("1", "8"))
//            .flattenConcat()
//            .map { NewsState(it.news, false, isLoadingMore = false, errorMessage = "") }
//            .flowOn(Dispatchers.IO) // case: change the upstream thread
//            .onStart {
//                emit(
//                    NewsState(
//                        emptyList(),
//                        true,
//                        isLoadingMore = false,
//                        errorMessage = ""
//                    )
//                )
//            }
//            .shareIn(viewModelScope, SharingStarted.Lazily)

    private fun Flow<FeedsIntent>.toPartialChangeFlow(): Flow<FeedsPartialChange> = merge(
        filterIsInstance<FeedsIntent.Init>().flatMapConcat { it.toPartialChangeFlow() },
        filterIsInstance<FeedsIntent.More>().flatMapConcat { it.toPartialChangeFlow() },
        filterIsInstance<FeedsIntent.Report>().flatMapConcat { it.toPartialChangeFlow() },
    )

    private fun FeedsIntent.More.toPartialChangeFlow() =
        newsRepo.remoteNewsFlow("", "10")
            .map { if (it.news.isEmpty()) More.Fail("no more news") else More.Success(it.news) }
            .onStart { emit(More.Loading) }
            .catch { emit(More.Fail("load more failed by xxx")) }


    private fun FeedsIntent.Init.toPartialChangeFlow(): Flow<FeedsPartialChange> =
        flowOf(
            newsRepo.localNewsOneShotFlow,
            newsRepo.remoteNewsFlow(this.type.toString(), this.count.toString())
        )
            .flattenMerge()
            .transformWhile(suspendFunction2())
            .map { news -> if (news.isEmpty()) Init.Fail("no more news") else Init.Success(news) }
            .onStart { emit(Init.Loading) }
            .catch {
                if (it is SSLHandshakeException)
                    emit(Init.Fail("network error,show old news"))
            }

    private fun suspendFunction2(): suspend FlowCollector<List<News>>.(value: NewsFlowWrapper) -> Boolean =
        {
            if (it.abort) {
                extracted(it)
            } else {
                emit(it.news)
                emit(it.news)
            }
            !it.abort
        }

    private suspend fun FlowCollector<List<News>>.extracted(
        it: NewsFlowWrapper
    ) {
        emit(it.news)
    }

    private fun FeedsIntent.Report.toPartialChangeFlow() =
        newsRepo.reportNews(id)
            .map { if (it >= 0L) Report.Success(it) else Report.Fail }
            .catch { emit((Report.Fail)) }

    private fun Flow<FeedsPartialChange>.sendEvent(): Flow<FeedsPartialChange> =
        onEach { partialChange ->
            val event = when (partialChange) {
                is Report.Fail -> FeedsEvent.Report.Result("举报失败")
                is Report.Success -> FeedsEvent.Report.Result("举报成功")
                else -> return@onEach
            }
            eventChannel.send(event)
        }

    /**
     * case: turn Intent flow to state flow
     */
//    private fun Flow<FeedsIntent>.toNewsStateFlow(): Flow<NewsState> = merge(
//        filterIsInstance<FeedsIntent.Init>()
//            .flatMapConcat { it.toFetchInitPageFlow() },
//        filterIsInstance<FeedsIntent.Report>()
//            .flatMapConcat { flow { } },
//        filterIsInstance<FeedsIntent.More>()
//            .flatMapConcat {
//                flow { emit(newsRepo.getLocalNewsBean()) }
//                    .map {
//                        NewsState(it.result ?: emptyList(), false, false, "")
//                    }
//            }
//    )

    /**
     * case: turn Intent to network fetching flow
     */
//    private fun FeedsIntent.Init.toFetchInitPageFlow() =
//        flowOf(
//            newsRepo.localNewsOneShotFlow,
//            newsRepo.remoteNewsFlow(this.type.toString(), this.count.toString())
//        )
//            .flattenMerge()
//            .transformWhile {
//                emit(it.news)
//                !it.abort
//            }
//            .map { NewsState(it, false, false, "") }
//            .catch {
//                if (it is SSLHandshakeException)
//                    emit(
//                        NewsState(
//                            emptyList(),
//                            isLoading = false,
//                            isLoadingMore = false,
//                            errorMessage = "network error,show old news"
//                        )
//                    )
//            }
}

/**
 * case: inject repo instance which need context as an input param
 */
class NewsViewModelFactory(private val newsRepo: NewsRepo) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return NewsViewModel(newsRepo) as T
    }
}
